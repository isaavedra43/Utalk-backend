#!/usr/bin/env node

/**
 * ‚ö° SCRIPT DE PRUEBA: FASE 6 - OPTIMIZACI√ìN Y MONITOREO
 * 
 * Este script valida todas las funcionalidades de optimizaci√≥n y monitoreo:
 * - Optimizaci√≥n de rendimiento con cache
 * - Procesamiento de archivos grandes en chunks
 * - Sistema de monitoreo y m√©tricas
 * - Alertas y thresholds
 * - Tests de carga y rendimiento
 * 
 * USO: node scripts/test-optimization-monitoring.js
 */

const { v4: uuidv4 } = require('uuid');
const fs = require('fs');
const path = require('path');

// Configurar logger
const logger = require('../src/utils/logger');

console.log('‚ö° ========================================');
console.log('‚ö° PRUEBA FASE 6: OPTIMIZACI√ìN Y MONITOREO');
console.log('‚ö° ========================================\n');

// Variables de prueba
const TEST_CONVERSATION_ID = 'test-optimization-conversation-' + Date.now();
const TEST_USER_EMAIL = 'test-optimization@example.com';

// Crear archivos de prueba de diferentes tama√±os
function createTestFile(sizeInMB) {
  const sizeInBytes = sizeInMB * 1024 * 1024;
  return Buffer.alloc(sizeInBytes, 'A'); // Llenar con 'A's
}

function createLargeTestFile(sizeInMB) {
  const sizeInBytes = sizeInMB * 1024 * 1024;
  const chunks = [];
  
  // Crear archivo grande en chunks para evitar problemas de memoria
  const chunkSize = 1024 * 1024; // 1MB chunks
  for (let i = 0; i < sizeInBytes; i += chunkSize) {
    const chunk = Buffer.alloc(Math.min(chunkSize, sizeInBytes - i), 'B');
    chunks.push(chunk);
  }
  
  return Buffer.concat(chunks);
}

/**
 * üß™ PRUEBA 1: OPTIMIZACI√ìN DE RENDIMIENTO
 */
async function testPerformanceOptimization() {
  console.log('üß™ PRUEBA 1: Optimizaci√≥n de rendimiento');
  try {
    const FileService = require('../src/services/FileService');
    const fileService = new FileService();
    
    // Probar archivos de diferentes tama√±os
    const testSizes = [1, 5, 10, 25, 50]; // MB
    const results = [];
    
    for (const sizeMB of testSizes) {
      console.log(`  üìÅ Probando archivo de ${sizeMB}MB...`);
      
      const testBuffer = createTestFile(sizeMB);
      const fileId = `test-optimization-${sizeMB}mb-${uuidv4()}`;
      
      const startTime = Date.now();
      
      const result = await fileService.processLargeFile(
        testBuffer,
        fileId,
        TEST_CONVERSATION_ID,
        {
          mimetype: 'application/octet-stream',
          optimize: true
        }
      );
      
      const processingTime = Date.now() - startTime;
      
      results.push({
        sizeMB,
        processingTime,
        result: result ? 'success' : 'failed',
        processedInChunks: result?.processedInChunks || false,
        totalChunks: result?.totalChunks || 0
      });
      
      console.log(`    ‚úÖ ${sizeMB}MB procesado en ${processingTime}ms`);
    }
    
    // Analizar resultados
    console.log('\nüìä An√°lisis de rendimiento:');
    results.forEach(result => {
      const speed = result.sizeMB / (result.processingTime / 1000); // MB/s
      console.log(`  ${result.sizeMB}MB: ${result.processingTime}ms (${speed.toFixed(2)} MB/s) - ${result.result}`);
    });
    
    // Verificar que archivos grandes se procesaron en chunks
    const largeFiles = results.filter(r => r.sizeMB >= 25);
    const chunkedFiles = largeFiles.filter(r => r.processedInChunks);
    
    console.log(`\n‚úÖ Archivos grandes procesados en chunks: ${chunkedFiles.length}/${largeFiles.length}`);
    
    return results.every(r => r.result === 'success');
    
  } catch (error) {
    console.error('‚ùå Error en prueba de optimizaci√≥n:', error.message);
    return false;
  }
}

/**
 * üß™ PRUEBA 2: SISTEMA DE CACHE
 */
async function testCacheSystem() {
  console.log('\nüß™ PRUEBA 2: Sistema de cache');
  try {
    const FileService = require('../src/services/FileService');
    const fileService = new FileService();
    
    const testBuffer = createTestFile(1); // 1MB
    const fileId = `test-cache-${uuidv4()}`;
    const options = { mimetype: 'text/plain' };
    
    console.log('  üîÑ Probando cache de archivos...');
    
    // Primera llamada - deber√≠a procesar y cachear
    const startTime1 = Date.now();
    const result1 = await fileService.processLargeFile(testBuffer, fileId, TEST_CONVERSATION_ID, options);
    const time1 = Date.now() - startTime1;
    
    console.log(`    Primera llamada: ${time1}ms`);
    
    // Segunda llamada - deber√≠a usar cache
    const startTime2 = Date.now();
    const result2 = await fileService.processLargeFile(testBuffer, fileId, TEST_CONVERSATION_ID, options);
    const time2 = Date.now() - startTime2;
    
    console.log(`    Segunda llamada: ${time2}ms`);
    
    // Verificar mejora de rendimiento
    const improvement = ((time1 - time2) / time1) * 100;
    console.log(`    Mejora de rendimiento: ${improvement.toFixed(1)}%`);
    
    // Obtener m√©tricas de cache
    const metrics = fileService.getPerformanceMetrics();
    console.log(`    Cache hits: ${metrics.cacheHits}`);
    console.log(`    Cache misses: ${metrics.cacheMisses}`);
    console.log(`    Tasa de acierto: ${metrics.cacheHitRate}`);
    
    const cacheEffective = time2 < time1 && metrics.cacheHits > 0;
    console.log(`    ‚úÖ Cache efectivo: ${cacheEffective ? 'S√ç' : 'NO'}`);
    
    return cacheEffective;
    
  } catch (error) {
    console.error('‚ùå Error en prueba de cache:', error.message);
    return false;
  }
}

/**
 * üß™ PRUEBA 3: SISTEMA DE MONITOREO
 */
async function testMonitoringSystem() {
  console.log('\nüß™ PRUEBA 3: Sistema de monitoreo');
  try {
    const fileMonitoringSystem = require('../src/utils/monitoring');
    
    console.log('  üìä Probando sistema de monitoreo...');
    
    // Simular procesamiento de archivos
    const testFiles = [
      { mimetype: 'image/jpeg', size: 1024 * 1024, success: true },
      { mimetype: 'video/mp4', size: 5 * 1024 * 1024, success: true },
      { mimetype: 'audio/mp3', size: 2 * 1024 * 1024, success: false },
      { mimetype: 'application/pdf', size: 3 * 1024 * 1024, success: true }
    ];
    
    for (const file of testFiles) {
      fileMonitoringSystem.recordFileProcessing({
        fileId: `test-monitoring-${uuidv4()}`,
        conversationId: TEST_CONVERSATION_ID,
        userId: 'test-user',
        mimetype: file.mimetype,
        size: file.size,
        processingTime: Math.random() * 1000 + 100,
        success: file.success,
        error: file.success ? null : new Error('Test error')
      });
    }
    
    // Obtener m√©tricas actuales
    const currentMetrics = fileMonitoringSystem.getCurrentMetrics();
    console.log(`    Archivos procesados: ${currentMetrics.files.totalProcessed}`);
    console.log(`    Archivos subidos: ${currentMetrics.files.totalUploaded}`);
    console.log(`    Errores totales: ${currentMetrics.errors.total}`);
    
    // Verificar categorizaci√≥n por tipo
    console.log('    Archivos por tipo:');
    Object.entries(currentMetrics.files.byType).forEach(([type, count]) => {
      if (count > 0) {
        console.log(`      ${type}: ${count}`);
      }
    });
    
    // Verificar categorizaci√≥n por tama√±o
    console.log('    Archivos por tama√±o:');
    Object.entries(currentMetrics.files.bySize).forEach(([size, count]) => {
      if (count > 0) {
        console.log(`      ${size}: ${count}`);
      }
    });
    
    // Obtener estad√≠sticas detalladas
    const detailedStats = fileMonitoringSystem.getDetailedStats();
    console.log(`    Tasa de error: ${detailedStats.overview.errorRate.toFixed(2)}%`);
    console.log(`    Tama√±o promedio: ${(detailedStats.overview.averageFileSize / 1024 / 1024).toFixed(2)}MB`);
    
    const monitoringWorking = currentMetrics.files.totalProcessed > 0 && 
                             currentMetrics.errors.total > 0;
    console.log(`    ‚úÖ Monitoreo funcionando: ${monitoringWorking ? 'S√ç' : 'NO'}`);
    
    return monitoringWorking;
    
  } catch (error) {
    console.error('‚ùå Error en prueba de monitoreo:', error.message);
    return false;
  }
}

/**
 * üß™ PRUEBA 4: ALERTAS Y THRESHOLDS
 */
async function testAlertsAndThresholds() {
  console.log('\nüß™ PRUEBA 4: Alertas y thresholds');
  try {
    const fileMonitoringSystem = require('../src/utils/monitoring');
    
    console.log('  üö® Probando sistema de alertas...');
    
    // Simular alta tasa de errores para trigger alerta
    for (let i = 0; i < 20; i++) {
      fileMonitoringSystem.recordFileProcessing({
        fileId: `test-alert-${uuidv4()}`,
        conversationId: TEST_CONVERSATION_ID,
        userId: 'test-user',
        mimetype: 'text/plain',
        size: 1024,
        processingTime: 100,
        success: false,
        error: new Error(`Test error ${i}`)
      });
    }
    
    // Verificar que se generaron alertas
    const currentMetrics = fileMonitoringSystem.getCurrentMetrics();
    const errorRate = currentMetrics.performance.errorRate;
    
    console.log(`    Tasa de error actual: ${errorRate.toFixed(2)}%`);
    console.log(`    Errores totales: ${currentMetrics.errors.total}`);
    
    // Verificar categorizaci√≥n de errores
    console.log('    Errores por categor√≠a:');
    Object.entries(currentMetrics.errors.byType).forEach(([category, count]) => {
      if (count > 0) {
        console.log(`      ${category}: ${count}`);
      }
    });
    
    // Verificar errores recientes
    const recentErrors = currentMetrics.errors.recent.slice(0, 5);
    console.log(`    Errores recientes: ${recentErrors.length}`);
    
    const alertsWorking = errorRate > 0 && currentMetrics.errors.total > 0;
    console.log(`    ‚úÖ Alertas funcionando: ${alertsWorking ? 'S√ç' : 'NO'}`);
    
    return alertsWorking;
    
  } catch (error) {
    console.error('‚ùå Error en prueba de alertas:', error.message);
    return false;
  }
}

/**
 * üß™ PRUEBA 5: M√âTRICAS DE RENDIMIENTO
 */
async function testPerformanceMetrics() {
  console.log('\nüß™ PRUEBA 5: M√©tricas de rendimiento');
  try {
    const FileService = require('../src/services/FileService');
    const fileService = new FileService();
    
    console.log('  ‚ö° Probando m√©tricas de rendimiento...');
    
    // Procesar varios archivos para generar m√©tricas
    const testFiles = [1, 2, 3, 4, 5]; // MB
    
    for (const sizeMB of testFiles) {
      const testBuffer = createTestFile(sizeMB);
      const fileId = `test-metrics-${sizeMB}mb-${uuidv4()}`;
      
      await fileService.processLargeFile(
        testBuffer,
        fileId,
        TEST_CONVERSATION_ID,
        { mimetype: 'application/octet-stream' }
      );
    }
    
    // Obtener m√©tricas de rendimiento
    const metrics = fileService.getPerformanceMetrics();
    
    console.log(`    Archivos procesados: ${metrics.filesProcessed}`);
    console.log(`    Cache hits: ${metrics.cacheHits}`);
    console.log(`    Cache misses: ${metrics.cacheMisses}`);
    console.log(`    Tasa de acierto de cache: ${metrics.cacheHitRate}`);
    console.log(`    Tiempo promedio de procesamiento: ${metrics.averageProcessingTime}`);
    console.log(`    Errores: ${metrics.errors}`);
    
    // Verificar tama√±os de cache
    console.log('    Tama√±os de cache:');
    Object.entries(metrics.cacheSize).forEach(([cacheType, size]) => {
      console.log(`      ${cacheType}: ${size} items`);
    });
    
    const metricsWorking = metrics.filesProcessed > 0 && 
                          typeof metrics.averageProcessingTime === 'string';
    console.log(`    ‚úÖ M√©tricas funcionando: ${metricsWorking ? 'S√ç' : 'NO'}`);
    
    return metricsWorking;
    
  } catch (error) {
    console.error('‚ùå Error en prueba de m√©tricas:', error.message);
    return false;
  }
}

/**
 * üß™ PRUEBA 6: TEST DE CARGA
 */
async function testLoadTesting() {
  console.log('\nüß™ PRUEBA 6: Test de carga');
  try {
    const FileService = require('../src/services/FileService');
    const fileService = new FileService();
    
    console.log('  üî• Probando carga del sistema...');
    
    const concurrentRequests = 10;
    const requests = [];
    
    // Crear m√∫ltiples requests concurrentes
    for (let i = 0; i < concurrentRequests; i++) {
      const testBuffer = createTestFile(0.5); // 500KB
      const fileId = `test-load-${i}-${uuidv4()}`;
      
      const request = fileService.processLargeFile(
        testBuffer,
        fileId,
        TEST_CONVERSATION_ID,
        { mimetype: 'text/plain' }
      ).then(result => ({ success: true, index: i }))
       .catch(error => ({ success: false, index: i, error: error.message }));
      
      requests.push(request);
    }
    
    // Ejecutar requests concurrentemente
    const startTime = Date.now();
    const results = await Promise.all(requests);
    const totalTime = Date.now() - startTime;
    
    // Analizar resultados
    const successfulRequests = results.filter(r => r.success).length;
    const failedRequests = results.filter(r => !r.success).length;
    
    console.log(`    Requests concurrentes: ${concurrentRequests}`);
    console.log(`    Requests exitosos: ${successfulRequests}`);
    console.log(`    Requests fallidos: ${failedRequests}`);
    console.log(`    Tiempo total: ${totalTime}ms`);
    console.log(`    Requests por segundo: ${(concurrentRequests / (totalTime / 1000)).toFixed(2)}`);
    
    const successRate = (successfulRequests / concurrentRequests) * 100;
    console.log(`    Tasa de √©xito: ${successRate.toFixed(1)}%`);
    
    const loadTestPassed = successRate >= 80; // Al menos 80% de √©xito
    console.log(`    ‚úÖ Test de carga: ${loadTestPassed ? 'PAS√ì' : 'FALL√ì'}`);
    
    return loadTestPassed;
    
  } catch (error) {
    console.error('‚ùå Error en test de carga:', error.message);
    return false;
  }
}

/**
 * üß™ PRUEBA 7: LIMPIEZA Y MANTENIMIENTO
 */
async function testCleanupAndMaintenance() {
  console.log('\nüß™ PRUEBA 7: Limpieza y mantenimiento');
  try {
    const fileMonitoringSystem = require('../src/utils/monitoring');
    const FileService = require('../src/services/FileService');
    const fileService = new FileService();
    
    console.log('  üßπ Probando limpieza autom√°tica...');
    
    // Verificar limpieza de cache
    const initialMetrics = fileService.getPerformanceMetrics();
    console.log(`    Cache inicial: ${JSON.stringify(initialMetrics.cacheSize)}`);
    
    // Simular tiempo para que expire cache
    console.log('    Simulando expiraci√≥n de cache...');
    
    // Verificar limpieza de historial
    const initialHistory = fileMonitoringSystem.history.hourly.length;
    console.log(`    Historial inicial: ${initialHistory} snapshots`);
    
    // Simular limpieza de historial
    console.log('    Simulando limpieza de historial...');
    
    // Verificar reset de m√©tricas
    console.log('    Probando reset de m√©tricas...');
    fileMonitoringSystem.resetMetrics();
    
    const resetMetrics = fileMonitoringSystem.getCurrentMetrics();
    const metricsReset = resetMetrics.files.totalProcessed === 0 && 
                        resetMetrics.errors.total === 0;
    
    console.log(`    ‚úÖ M√©tricas reseteadas: ${metricsReset ? 'S√ç' : 'NO'}`);
    
    return metricsReset;
    
  } catch (error) {
    console.error('‚ùå Error en prueba de limpieza:', error.message);
    return false;
  }
}

/**
 * FUNCI√ìN PRINCIPAL DE PRUEBA
 */
async function runAllTests() {
  console.log('üöÄ Iniciando pruebas de optimizaci√≥n y monitoreo...\n');
  
  const tests = [
    { name: 'Optimizaci√≥n de rendimiento', fn: testPerformanceOptimization },
    { name: 'Sistema de cache', fn: testCacheSystem },
    { name: 'Sistema de monitoreo', fn: testMonitoringSystem },
    { name: 'Alertas y thresholds', fn: testAlertsAndThresholds },
    { name: 'M√©tricas de rendimiento', fn: testPerformanceMetrics },
    { name: 'Test de carga', fn: testLoadTesting },
    { name: 'Limpieza y mantenimiento', fn: testCleanupAndMaintenance }
  ];
  
  const results = [];
  
  for (const test of tests) {
    console.log(`\nüéØ Ejecutando: ${test.name}`);
    console.log('‚îÄ'.repeat(50));
    
    const startTime = Date.now();
    const result = await test.fn();
    const duration = Date.now() - startTime;
    
    results.push({
      name: test.name,
      success: result,
      duration: duration
    });
    
    console.log(`\n${result ? '‚úÖ' : '‚ùå'} ${test.name}: ${result ? 'EXITOSO' : 'FALLIDO'} (${duration}ms)`);
  }
  
  // Resumen final
  console.log('\n‚ö° ========================================');
  console.log('‚ö° RESUMEN DE PRUEBAS FASE 6');
  console.log('‚ö° ========================================');
  
  const successfulTests = results.filter(r => r.success).length;
  const totalTests = results.length;
  const totalTime = results.reduce((sum, r) => sum + r.duration, 0);
  
  console.log(`\nüìä Resultados:`);
  console.log(`   ‚úÖ Exitosos: ${successfulTests}/${totalTests}`);
  console.log(`   ‚ùå Fallidos: ${totalTests - successfulTests}/${totalTests}`);
  console.log(`   ‚è±Ô∏è Tiempo total: ${totalTime}ms`);
  
  console.log('\nüìã Detalles por prueba:');
  results.forEach((result, index) => {
    const status = result.success ? '‚úÖ' : '‚ùå';
    console.log(`   ${index + 1}. ${status} ${result.name} (${result.duration}ms)`);
  });
  
  if (successfulTests === totalTests) {
    console.log('\nüéâ ¬°TODAS LAS PRUEBAS EXITOSAS!');
    console.log('‚ö° La Fase 6: Optimizaci√≥n y monitoreo est√° funcionando correctamente.');
  } else {
    console.log('\n‚ö†Ô∏è Algunas pruebas fallaron. Revisar logs para m√°s detalles.');
  }
  
  console.log('\n‚ö° ========================================');
  
  return successfulTests === totalTests;
}

// Ejecutar pruebas si el script se ejecuta directamente
if (require.main === module) {
  runAllTests()
    .then(success => {
      process.exit(success ? 0 : 1);
    })
    .catch(error => {
      console.error('‚ùå Error cr√≠tico en las pruebas:', error);
      process.exit(1);
    });
}

module.exports = {
  testPerformanceOptimization,
  testCacheSystem,
  testMonitoringSystem,
  testAlertsAndThresholds,
  testPerformanceMetrics,
  testLoadTesting,
  testCleanupAndMaintenance,
  runAllTests
}; 