/**
 * üß™ SCRIPT DE PRUEBA: SISTEMA DE REFRESH TOKENS
 * 
 * Prueba completa del flujo de autenticaci√≥n con refresh tokens:
 * 1. Login ‚Üí 2. Acceso ‚Üí 3. Expiraci√≥n ‚Üí 4. Renovaci√≥n ‚Üí 5. Logout
 * 
 * @version 1.0.0
 * @author Backend Team
 */

const axios = require('axios');
const jwt = require('jsonwebtoken');

// Configuraci√≥n
const BASE_URL = process.env.API_URL || 'http://localhost:3000';
const TEST_EMAIL = 'test@example.com';
const TEST_PASSWORD = 'testpassword123';

/**
 * Clase para manejar las pruebas del sistema de refresh tokens
 */
class RefreshTokenTester {
  constructor() {
    this.accessToken = null;
    this.refreshToken = null;
    this.user = null;
    this.testResults = [];
  }

  /**
   * Log de prueba
   */
  log(message, data = {}) {
    const timestamp = new Date().toISOString();
    console.log(`[${timestamp}] ${message}`, data);
    this.testResults.push({ timestamp, message, data });
  }

  /**
   * Hacer petici√≥n HTTP
   */
  async makeRequest(method, endpoint, data = null, headers = {}) {
    try {
      const config = {
        method,
        url: `${BASE_URL}${endpoint}`,
        headers: {
          'Content-Type': 'application/json',
          ...headers
        }
      };

      if (data) {
        config.data = data;
      }

      const response = await axios(config);
      return response;
    } catch (error) {
      return {
        status: error.response?.status || 500,
        data: error.response?.data || { error: error.message }
      };
    }
  }

  /**
   * Prueba 1: Login exitoso
   */
  async testLogin() {
    this.log('üß™ PRUEBA 1: Login exitoso');

    const loginData = {
      email: TEST_EMAIL,
      password: TEST_PASSWORD
    };

    const response = await this.makeRequest('POST', '/api/auth/login', loginData);

    if (response.status === 200 && response.data.success) {
      this.accessToken = response.data.accessToken;
      this.refreshToken = response.data.refreshToken;
      this.user = response.data.user;

      this.log('‚úÖ Login exitoso', {
        accessTokenLength: this.accessToken?.length,
        refreshTokenLength: this.refreshToken?.length,
        userEmail: this.user?.email,
        expiresIn: response.data.expiresIn,
        refreshExpiresIn: response.data.refreshExpiresIn
      });

      return true;
    } else {
      this.log('‚ùå Login fallido', {
        status: response.status,
        error: response.data?.error,
        message: response.data?.message
      });
      return false;
    }
  }

  /**
   * Prueba 2: Acceso con token v√°lido
   */
  async testValidAccess() {
    this.log('üß™ PRUEBA 2: Acceso con token v√°lido');

    if (!this.accessToken) {
      this.log('‚ùå No hay access token disponible');
      return false;
    }

    const response = await this.makeRequest('POST', '/api/auth/validate-token', {}, {
      'Authorization': `Bearer ${this.accessToken}`
    });

    if (response.status === 200 && response.data.success) {
      this.log('‚úÖ Acceso v√°lido', {
        userEmail: response.data.data?.user?.email,
        sessionValid: response.data.data?.sessionValid
      });
      return true;
    } else {
      this.log('‚ùå Acceso inv√°lido', {
        status: response.status,
        error: response.data?.error,
        message: response.data?.message
      });
      return false;
    }
  }

  /**
   * Prueba 3: Acceso a endpoint protegido
   */
  async testProtectedEndpoint() {
    this.log('üß™ PRUEBA 3: Acceso a endpoint protegido');

    if (!this.accessToken) {
      this.log('‚ùå No hay access token disponible');
      return false;
    }

    const response = await this.makeRequest('GET', '/api/auth/profile', {}, {
      'Authorization': `Bearer ${this.accessToken}`
    });

    if (response.status === 200 && response.data.success) {
      this.log('‚úÖ Endpoint protegido accesible', {
        userEmail: response.data.user?.email,
        userName: response.data.user?.name
      });
      return true;
    } else {
      this.log('‚ùå Endpoint protegido inaccesible', {
        status: response.status,
        error: response.data?.error,
        message: response.data?.message
      });
      return false;
    }
  }

  /**
   * Prueba 4: Simular token expirado
   */
  async testExpiredToken() {
    this.log('üß™ PRUEBA 4: Simular token expirado');

    // Crear un token que expire en 1 segundo
    const expiredToken = jwt.sign(
      {
        email: this.user?.email,
        role: this.user?.role,
        name: this.user?.name,
        type: 'access',
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + 1 // Expira en 1 segundo
      },
      process.env.JWT_SECRET || 'test-secret',
      {
        issuer: 'utalk-backend',
        audience: 'utalk-frontend'
      }
    );

    // Esperar 2 segundos para que expire
    await new Promise(resolve => setTimeout(resolve, 2000));

    const response = await this.makeRequest('POST', '/api/auth/validate-token', {}, {
      'Authorization': `Bearer ${expiredToken}`
    });

    if (response.status === 401 && response.data?.code === 'TOKEN_EXPIRED') {
      this.log('‚úÖ Token expirado detectado correctamente', {
        error: response.data?.error,
        code: response.data?.code
      });
      return true;
    } else {
      this.log('‚ùå Token expirado no detectado', {
        status: response.status,
        data: response.data
      });
      return false;
    }
  }

  /**
   * Prueba 5: Renovaci√≥n de token
   */
  async testTokenRefresh() {
    this.log('üß™ PRUEBA 5: Renovaci√≥n de token');

    if (!this.refreshToken) {
      this.log('‚ùå No hay refresh token disponible');
      return false;
    }

    const response = await this.makeRequest('POST', '/api/auth/refresh', {
      refreshToken: this.refreshToken
    });

    if (response.status === 200 && response.data.success) {
      const newAccessToken = response.data.accessToken;
      const newRefreshToken = response.data.refreshToken;

      this.log('‚úÖ Token renovado exitosamente', {
        newAccessTokenLength: newAccessToken?.length,
        newRefreshTokenLength: newRefreshToken?.length,
        expiresIn: response.data.expiresIn,
        tokenRotated: response.data.tokenRotated || false
      });

      // Actualizar tokens
      this.accessToken = newAccessToken;
      if (newRefreshToken) {
        this.refreshToken = newRefreshToken;
      }

      return true;
    } else {
      this.log('‚ùå Renovaci√≥n de token fallida', {
        status: response.status,
        error: response.data?.error,
        message: response.data?.message
      });
      return false;
    }
  }

  /**
   * Prueba 6: Acceso con token renovado
   */
  async testRefreshedTokenAccess() {
    this.log('üß™ PRUEBA 6: Acceso con token renovado');

    if (!this.accessToken) {
      this.log('‚ùå No hay access token renovado disponible');
      return false;
    }

    const response = await this.makeRequest('GET', '/api/auth/profile', {}, {
      'Authorization': `Bearer ${this.accessToken}`
    });

    if (response.status === 200 && response.data.success) {
      this.log('‚úÖ Acceso con token renovado exitoso', {
        userEmail: response.data.user?.email,
        userName: response.data.user?.name
      });
      return true;
    } else {
      this.log('‚ùå Acceso con token renovado fallido', {
        status: response.status,
        error: response.data?.error,
        message: response.data?.message
      });
      return false;
    }
  }

  /**
   * Prueba 7: Obtener sesiones activas
   */
  async testActiveSessions() {
    this.log('üß™ PRUEBA 7: Obtener sesiones activas');

    if (!this.accessToken) {
      this.log('‚ùå No hay access token disponible');
      return false;
    }

    const response = await this.makeRequest('GET', '/api/auth/sessions', {}, {
      'Authorization': `Bearer ${this.accessToken}`
    });

    if (response.status === 200 && response.data.success) {
      this.log('‚úÖ Sesiones activas obtenidas', {
        sessionCount: response.data.count,
        sessions: response.data.sessions?.length || 0
      });
      return true;
    } else {
      this.log('‚ùå Error obteniendo sesiones activas', {
        status: response.status,
        error: response.data?.error,
        message: response.data?.message
      });
      return false;
    }
  }

  /**
   * Prueba 8: Logout con invalidaci√≥n
   */
  async testLogout() {
    this.log('üß™ PRUEBA 8: Logout con invalidaci√≥n');

    if (!this.accessToken) {
      this.log('‚ùå No hay access token disponible');
      return false;
    }

    const response = await this.makeRequest('POST', '/api/auth/logout', {
      refreshToken: this.refreshToken,
      invalidateAll: true
    }, {
      'Authorization': `Bearer ${this.accessToken}`
    });

    if (response.status === 200 && response.data.success) {
      this.log('‚úÖ Logout exitoso', {
        invalidatedTokens: response.data.invalidatedTokens
      });
      return true;
    } else {
      this.log('‚ùå Logout fallido', {
        status: response.status,
        error: response.data?.error,
        message: response.data?.message
      });
      return false;
    }
  }

  /**
   * Prueba 9: Verificar invalidaci√≥n de tokens
   */
  async testTokenInvalidation() {
    this.log('üß™ PRUEBA 9: Verificar invalidaci√≥n de tokens');

    if (!this.accessToken) {
      this.log('‚ùå No hay access token disponible');
      return false;
    }

    const response = await this.makeRequest('POST', '/api/auth/validate-token', {}, {
      'Authorization': `Bearer ${this.accessToken}`
    });

    if (response.status === 401) {
      this.log('‚úÖ Token invalidado correctamente', {
        error: response.data?.error,
        code: response.data?.code
      });
      return true;
    } else {
      this.log('‚ùå Token no invalidado', {
        status: response.status,
        data: response.data
      });
      return false;
    }
  }

  /**
   * Prueba 10: Renovaci√≥n con token invalidado
   */
  async testRefreshWithInvalidToken() {
    this.log('üß™ PRUEBA 10: Renovaci√≥n con token invalidado');

    if (!this.refreshToken) {
      this.log('‚ùå No hay refresh token disponible');
      return false;
    }

    const response = await this.makeRequest('POST', '/api/auth/refresh', {
      refreshToken: this.refreshToken
    });

    if (response.status === 401) {
      this.log('‚úÖ Renovaci√≥n con token invalidado rechazada correctamente', {
        error: response.data?.error,
        code: response.data?.code
      });
      return true;
    } else {
      this.log('‚ùå Renovaci√≥n con token invalidado no fue rechazada', {
        status: response.status,
        data: response.data
      });
      return false;
    }
  }

  /**
   * Ejecutar todas las pruebas
   */
  async runAllTests() {
    console.log('üöÄ INICIANDO PRUEBAS DEL SISTEMA DE REFRESH TOKENS');
    console.log('=' .repeat(60));

    const tests = [
      { name: 'Login', fn: () => this.testLogin() },
      { name: 'Acceso v√°lido', fn: () => this.testValidAccess() },
      { name: 'Endpoint protegido', fn: () => this.testProtectedEndpoint() },
      { name: 'Token expirado', fn: () => this.testExpiredToken() },
      { name: 'Renovaci√≥n de token', fn: () => this.testTokenRefresh() },
      { name: 'Acceso con token renovado', fn: () => this.testRefreshedTokenAccess() },
      { name: 'Sesiones activas', fn: () => this.testActiveSessions() },
      { name: 'Logout', fn: () => this.testLogout() },
      { name: 'Invalidaci√≥n de tokens', fn: () => this.testTokenInvalidation() },
      { name: 'Renovaci√≥n con token invalidado', fn: () => this.testRefreshWithInvalidToken() }
    ];

    let passedTests = 0;
    let totalTests = tests.length;

    for (const test of tests) {
      try {
        const result = await test.fn();
        if (result) {
          passedTests++;
          console.log(`‚úÖ ${test.name}: PAS√ì`);
        } else {
          console.log(`‚ùå ${test.name}: FALL√ì`);
        }
      } catch (error) {
        console.log(`üí• ${test.name}: ERROR - ${error.message}`);
      }
      
      console.log('-'.repeat(40));
    }

    console.log('\nüìä RESUMEN DE PRUEBAS:');
    console.log(`‚úÖ Pruebas pasadas: ${passedTests}/${totalTests}`);
    console.log(`‚ùå Pruebas fallidas: ${totalTests - passedTests}/${totalTests}`);
    console.log(`üìà Tasa de √©xito: ${((passedTests / totalTests) * 100).toFixed(1)}%`);

    if (passedTests === totalTests) {
      console.log('\nüéâ ¬°TODAS LAS PRUEBAS PASARON! El sistema de refresh tokens est√° funcionando correctamente.');
    } else {
      console.log('\n‚ö†Ô∏è Algunas pruebas fallaron. Revisa los logs para m√°s detalles.');
    }

    return {
      passed: passedTests,
      total: totalTests,
      successRate: (passedTests / totalTests) * 100,
      results: this.testResults
    };
  }
}

/**
 * Funci√≥n principal
 */
async function main() {
  try {
    const tester = new RefreshTokenTester();
    const results = await tester.runAllTests();
    
    // Guardar resultados en archivo
    const fs = require('fs');
    const resultsFile = `refresh-token-test-results-${Date.now()}.json`;
    fs.writeFileSync(resultsFile, JSON.stringify(results, null, 2));
    
    console.log(`\nüìÑ Resultados guardados en: ${resultsFile}`);
    
    process.exit(results.passed === results.total ? 0 : 1);
  } catch (error) {
    console.error('üí• Error ejecutando pruebas:', error.message);
    process.exit(1);
  }
}

// Ejecutar si el script se ejecuta directamente
if (require.main === module) {
  main();
}

module.exports = RefreshTokenTester; 