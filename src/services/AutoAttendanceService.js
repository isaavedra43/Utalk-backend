const Employee = require('../models/Employee');
const AttendanceRecord = require('../models/AttendanceRecord');
const PayrollMovement = require('../models/PayrollMovement');
const { db } = require('../config/firebase');

/**
 * Servicio para automatizar el registro de asistencia
 */
class AutoAttendanceService {
  
  /**
   * Procesa la asistencia autom√°tica para todos los empleados activos
   */
  static async processDailyAttendance(date = null) {
    try {
      const targetDate = date || new Date().toISOString().split('T')[0];
      console.log(`üîÑ Procesando asistencia autom√°tica para: ${targetDate}`);
      
      // Obtener todos los empleados activos
      const activeEmployees = await Employee.findActive();
      console.log(`üë• Empleados activos encontrados: ${activeEmployees.length}`);
      
      const results = {
        processed: 0,
        created: 0,
        updated: 0,
        errors: 0,
        details: []
      };
      
      for (const employee of activeEmployees) {
        try {
          const result = await this.processEmployeeAttendance(employee, targetDate);
          results.processed++;
          results.created += result.created ? 1 : 0;
          results.updated += result.updated ? 1 : 0;
          results.details.push({
            employeeId: employee.id,
            employeeName: `${employee.personalInfo.firstName} ${employee.personalInfo.lastName}`,
            status: result.status,
            action: result.action
          });
        } catch (error) {
          console.error(`‚ùå Error procesando empleado ${employee.id}:`, error);
          results.errors++;
          results.details.push({
            employeeId: employee.id,
            employeeName: `${employee.personalInfo.firstName} ${employee.personalInfo.lastName}`,
            status: 'error',
            action: 'failed',
            error: error.message
          });
        }
      }
      
      console.log(`‚úÖ Procesamiento completado:`, results);
      return results;
      
    } catch (error) {
      console.error('‚ùå Error en procesamiento autom√°tico de asistencia:', error);
      throw error;
    }
  }
  
  /**
   * Procesa la asistencia para un empleado espec√≠fico
   */
  static async processEmployeeAttendance(employee, date) {
    try {
      // Verificar si ya existe un registro para esta fecha
      const existingRecord = await AttendanceRecord.findByEmployeeAndDate(employee.id, date);
      
      if (existingRecord) {
        console.log(`üìù Registro existente para ${employee.personalInfo.firstName} en ${date}`);
        return {
          status: 'exists',
          action: 'skipped',
          created: false,
          updated: false
        };
      }
      
      // Verificar si es d√≠a laboral
      const isWorkingDay = this.isWorkingDay(employee, date);
      
      if (!isWorkingDay) {
        console.log(`üè† ${employee.personalInfo.firstName} no trabaja los ${this.getDayName(date)}`);
        return {
          status: 'non_working_day',
          action: 'skipped',
          created: false,
          updated: false
        };
      }
      
      // Crear registro de asistencia autom√°tico
      const attendanceRecord = await this.createAutoAttendanceRecord(employee, date);
      
      console.log(`‚úÖ Registro creado para ${employee.personalInfo.firstName} en ${date}`);
      return {
        status: 'created',
        action: 'created',
        created: true,
        updated: false,
        record: attendanceRecord
      };
      
    } catch (error) {
      console.error(`‚ùå Error procesando asistencia de ${employee.personalInfo.firstName}:`, error);
      throw error;
    }
  }
  
  /**
   * Crea un registro de asistencia autom√°tico
   */
  static async createAutoAttendanceRecord(employee, date) {
    try {
      const workingHours = this.getWorkingHours(employee, date);
      const dailySalary = this.calculateDailySalary(employee);
      
      const attendanceData = {
        employeeId: employee.id,
        date: date,
        checkIn: workingHours.startTime,
        checkOut: workingHours.endTime,
        totalHours: workingHours.totalHours,
        overtimeHours: Math.max(0, workingHours.totalHours - 8),
        status: 'present',
        location: employee.location?.isRemote ? 'remote' : 'office',
        notes: 'Registro autom√°tico generado por el sistema',
        registeredBy: 'system',
        registeredAt: new Date().toISOString(),
        isAutoGenerated: true,
        salary: {
          dailySalary: dailySalary,
          hoursWorked: workingHours.totalHours,
          overtimeAmount: 0 // Se calcular√° si hay horas extra
        }
      };
      
      const attendanceRecord = new AttendanceRecord(attendanceData);
      await attendanceRecord.save();
      
      return attendanceRecord;
      
    } catch (error) {
      console.error('‚ùå Error creando registro autom√°tico:', error);
      throw error;
    }
  }
  
  /**
   * Verifica si es d√≠a laboral para el empleado
   */
  static isWorkingDay(employee, date) {
    const dayOfWeek = new Date(date).getDay();
    const dayNames = ['domingo', 'lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado'];
    const dayName = dayNames[dayOfWeek];
    
    // Verificar horario personalizado
    if (employee.contract?.customSchedule?.enabled) {
      return employee.contract.customSchedule.days[dayName]?.enabled || false;
    }
    
    // Verificar d√≠as laborales por defecto (Lunes a Viernes)
    return dayOfWeek >= 1 && dayOfWeek <= 5;
  }
  
  /**
   * Obtiene las horas de trabajo para el empleado en una fecha espec√≠fica
   */
  static getWorkingHours(employee, date) {
    const dayOfWeek = new Date(date).getDay();
    const dayNames = ['domingo', 'lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado'];
    const dayName = dayNames[dayOfWeek];
    
    let startTime, endTime;
    
    // Verificar horario personalizado
    if (employee.contract?.customSchedule?.enabled) {
      const daySchedule = employee.contract.customSchedule.days[dayName];
      startTime = daySchedule?.startTime || '09:00';
      endTime = daySchedule?.endTime || '18:00';
    } else {
      // Horario por defecto
      const workingHoursRange = employee.contract?.workingHoursRange || '09:00-18:00';
      [startTime, endTime] = workingHoursRange.split('-');
    }
    
    // Calcular horas totales
    const start = this.timeToMinutes(startTime);
    const end = this.timeToMinutes(endTime);
    const totalMinutes = end - start;
    const totalHours = totalMinutes / 60;
    
    return {
      startTime,
      endTime,
      totalHours,
      totalMinutes
    };
  }
  
  /**
   * Calcula el salario diario del empleado
   */
  static calculateDailySalary(employee) {
    const monthlySalary = employee.contract?.salary || employee.salary?.baseSalary || 0;
    
    if (monthlySalary > 0) {
      // Salario mensual dividido entre 30 d√≠as
      return monthlySalary / 30;
    }
    
    return 0;
  }
  
  /**
   * Convierte tiempo (HH:MM) a minutos
   */
  static timeToMinutes(timeString) {
    const [hours, minutes] = timeString.split(':').map(Number);
    return hours * 60 + minutes;
  }
  
  /**
   * Obtiene el nombre del d√≠a en espa√±ol
   */
  static getDayName(date) {
    const dayOfWeek = new Date(date).getDay();
    const dayNames = ['Domingo', 'Lunes', 'Martes', 'Mi√©rcoles', 'Jueves', 'Viernes', 'S√°bado'];
    return dayNames[dayOfWeek];
  }
  
  /**
   * Procesa asistencia para un rango de fechas
   */
  static async processDateRange(startDate, endDate) {
    try {
      const results = {
        totalDays: 0,
        processed: 0,
        created: 0,
        errors: 0,
        dailyResults: []
      };
      
      const currentDate = new Date(startDate);
      const end = new Date(endDate);
      
      while (currentDate <= end) {
        const dateString = currentDate.toISOString().split('T')[0];
        results.totalDays++;
        
        try {
          const dailyResult = await this.processDailyAttendance(dateString);
          results.processed += dailyResult.processed;
          results.created += dailyResult.created;
          results.errors += dailyResult.errors;
          results.dailyResults.push({
            date: dateString,
            ...dailyResult
          });
        } catch (error) {
          console.error(`‚ùå Error procesando fecha ${dateString}:`, error);
          results.errors++;
        }
        
        currentDate.setDate(currentDate.getDate() + 1);
      }
      
      return results;
      
    } catch (error) {
      console.error('‚ùå Error procesando rango de fechas:', error);
      throw error;
    }
  }
  
  /**
   * Obtiene estad√≠sticas de asistencia autom√°tica
   */
  static async getAutoAttendanceStats(startDate, endDate) {
    try {
      const snapshot = await db.collection('employees')
        .get();
      
      let totalRecords = 0;
      let autoGeneratedRecords = 0;
      let manualRecords = 0;
      
      for (const employeeDoc of snapshot.docs) {
        const attendanceSnapshot = await db.collection('employees')
          .doc(employeeDoc.id)
          .collection('attendance')
          .where('date', '>=', startDate)
          .where('date', '<=', endDate)
          .get();
        
        attendanceSnapshot.docs.forEach(doc => {
          const data = doc.data();
          totalRecords++;
          
          if (data.isAutoGenerated) {
            autoGeneratedRecords++;
          } else {
            manualRecords++;
          }
        });
      }
      
      return {
        totalRecords,
        autoGeneratedRecords,
        manualRecords,
        autoPercentage: totalRecords > 0 ? (autoGeneratedRecords / totalRecords) * 100 : 0
      };
      
    } catch (error) {
      console.error('‚ùå Error obteniendo estad√≠sticas:', error);
      throw error;
    }
  }
}

module.exports = AutoAttendanceService;
