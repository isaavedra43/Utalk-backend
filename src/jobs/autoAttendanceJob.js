const cron = require('node-cron');
const AutoAttendanceService = require('../services/AutoAttendanceService');

/**
 * Tarea programada para procesar asistencia autom√°tica
 */
class AutoAttendanceJob {
  
  constructor() {
    this.isRunning = false;
    this.lastRun = null;
    this.nextRun = null;
  }
  
  /**
   * Inicia la tarea programada
   */
  start() {
    console.log('üïê Iniciando tarea programada de asistencia autom√°tica...');
    
    // Ejecutar todos los d√≠as a las 6:00 AM (hora del servidor)
    this.scheduledTask = cron.schedule('0 6 * * *', async () => {
      await this.runDailyAttendance();
    }, {
      scheduled: false,
      timezone: "America/Mexico_City"
    });
    
    // Ejecutar todos los d√≠as a las 6:00 PM para verificar registros del d√≠a
    this.verificationTask = cron.schedule('0 18 * * *', async () => {
      await this.verifyDailyAttendance();
    }, {
      scheduled: false,
      timezone: "America/Mexico_City"
    });
    
    this.scheduledTask.start();
    this.verificationTask.start();
    
    console.log('‚úÖ Tarea programada iniciada correctamente');
    console.log('üìÖ Horarios: 6:00 AM (registro) y 6:00 PM (verificaci√≥n)');
  }
  
  /**
   * Detiene la tarea programada
   */
  stop() {
    if (this.scheduledTask) {
      this.scheduledTask.stop();
    }
    if (this.verificationTask) {
      this.verificationTask.stop();
    }
    console.log('‚èπÔ∏è Tarea programada detenida');
  }
  
  /**
   * Ejecuta el procesamiento diario de asistencia
   */
  async runDailyAttendance() {
    if (this.isRunning) {
      console.log('‚ö†Ô∏è Tarea de asistencia autom√°tica ya est√° ejecut√°ndose, saltando...');
      return;
    }
    
    this.isRunning = true;
    this.lastRun = new Date();
    
    try {
      console.log('üöÄ Iniciando procesamiento autom√°tico de asistencia...');
      
      const result = await AutoAttendanceService.processDailyAttendance();
      
      console.log('‚úÖ Procesamiento autom√°tico completado:', {
        processed: result.processed,
        created: result.created,
        errors: result.errors,
        timestamp: this.lastRun.toISOString()
      });
      
      // Log detallado de resultados
      if (result.details && result.details.length > 0) {
        console.log('üìä Detalles del procesamiento:');
        result.details.forEach(detail => {
          console.log(`  - ${detail.employeeName}: ${detail.status} (${detail.action})`);
        });
      }
      
    } catch (error) {
      console.error('‚ùå Error en procesamiento autom√°tico de asistencia:', error);
    } finally {
      this.isRunning = false;
    }
  }
  
  /**
   * Verifica los registros de asistencia del d√≠a
   */
  async verifyDailyAttendance() {
    try {
      console.log('üîç Verificando registros de asistencia del d√≠a...');
      
      const today = new Date().toISOString().split('T')[0];
      const stats = await AutoAttendanceService.getAutoAttendanceStats(today, today);
      
      console.log('üìà Estad√≠sticas del d√≠a:', {
        date: today,
        totalRecords: stats.totalRecords,
        autoGenerated: stats.autoGeneratedRecords,
        manual: stats.manualRecords,
        autoPercentage: stats.autoPercentage.toFixed(2) + '%'
      });
      
    } catch (error) {
      console.error('‚ùå Error verificando asistencia del d√≠a:', error);
    }
  }
  
  /**
   * Ejecuta la tarea manualmente (para testing)
   */
  async runManually(date = null) {
    console.log('üîß Ejecutando tarea manual de asistencia autom√°tica...');
    await this.runDailyAttendance();
  }
  
  /**
   * Obtiene el estado de la tarea programada
   */
  getStatus() {
    return {
      isRunning: this.isRunning,
      lastRun: this.lastRun,
      nextRun: this.nextRun,
      scheduled: this.scheduledTask ? this.scheduledTask.running : false,
      verification: this.verificationTask ? this.verificationTask.running : false
    };
  }
  
  /**
   * Procesa asistencia para un rango de fechas espec√≠fico
   */
  async processDateRange(startDate, endDate) {
    try {
      console.log(`üìÖ Procesando asistencia del ${startDate} al ${endDate}...`);
      
      const result = await AutoAttendanceService.processDateRange(startDate, endDate);
      
      console.log('‚úÖ Procesamiento de rango completado:', {
        totalDays: result.totalDays,
        processed: result.processed,
        created: result.created,
        errors: result.errors
      });
      
      return result;
      
    } catch (error) {
      console.error('‚ùå Error procesando rango de fechas:', error);
      throw error;
    }
  }
}

// Instancia singleton
const autoAttendanceJob = new AutoAttendanceJob();

module.exports = autoAttendanceJob;
